# 三角形的光栅化
> 屏幕采样

所有的物体都会在[-1,1]的立方体里, 之后画在屏幕上可以称为光栅化

垂直可视角度

水平可视角度

屏幕： 二维数组， 每一个元素是一个像素
> 光栅

一个像素内的颜色都可以用rgb来表示， 并且一个像素内的颜色不会不同

原点在左下角

像素的坐标都是写为x,y

1. 视口变换，将立方体移动到屏幕矩形内。

2. 打散成像素

lcd/led  

判断像素的中心(x+0.5, y+0.5)是否在三角形内： 逆时针三个点 形成向量与点差积， 判断左右

三角形的包围和

像素如果刚好在边缘，则看自己定义

锯齿： 像素本身有一定的大小， 采样率不够高， 导致走样aliasing

### 抗锯齿/反走样

采样发生的问题（artifacts：瑕疵）：

 1. 锯齿
 2. 摩尔纹
 3. 车轮效应： 时间采样


如何解决： 

  1. 采样之前先做模糊， 滤波， 然后采样。 msaa
  > 去掉高频信号

      频率： frequency  1/T

      正弦波，余弦波
      
      傅里叶级数展开： 任何一个周期函数都可以写成一系列正弦和余弦函数和一项常数的线性组合
      fx = a/2+ 2acos/pai -2acos/3pai+...

      走样： 同一个采样方法采样不同频率的函数无法分析出不同。

      傅里叶变换： 从时域变成频域

      滤波去掉一部分特定的频率

      高通滤波： 只剩下高频， （图像的边界）

      低通滤波： 只留下低频信号（去掉边界）

      数字图像处理

      滤波 = 卷积（平均）

      卷积： 窗口在频域上移动， 加权平均，
      定理： 时域卷积 = 频域乘积

      采样： 原始信号乘以一系列冲击函数

      更多的采样来进行反走样 msaa： 一个像素添加采样点，来算模糊，增加了计算量

  2. 增加采样率

  3. fxaa： fast approximate aa
  > 得到有锯齿的图，找到锯齿，修改
  
  4. taa : temporal aa
  > 找上一帧的信息， 复用上一帧信息。

### 超分辨率

图像拉大

dlss： 深度学习， 猜测信息， 补全。

### 深度缓冲： z-buffering， 深度信息如何正确遮挡关系
> 处理不了透明物体

画家算法 painter's algorithm： 先光栅化远的面  排序时间复杂度O(nlogn)

如何定义深度？ 引入一个概念，算法： 深度缓冲

生成最后图像（frame buffer）的同时，还会生成任何一个像素看到的最浅的深度信息（depth buffer）的图。 O(n)。


















