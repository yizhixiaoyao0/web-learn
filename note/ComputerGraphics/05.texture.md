# Texture Mapping
> 纹理映射

不同的材质就是不同的着色方法；

纹理就是在着色的时候添加细节， 不同的计算方法；

定义任何一点的属性， 任何一个三维物体表面都是二维的。

* 纹理空间，纹理坐标系UV， 范围U，V都在0-1内， 三角形每一个顶点对应一个uv

* tiled（无缝贴图）

* 重心坐标， 三角形内部任何属性的差值

    - 三角形内部为什么要插值？

      很多属性都在三角形顶点上， 为了三角形内部平滑显示, 纹理， gouraud shading， 深度差值。

    - 怎么做插值

      ABC三个点形成三角形， 里面任意一个点(x,y)可以用以下线性组合表示

      (x,y) = aA + bB + cC  ;  三角形内还需满足  a+b+c=1， 根据面积来算比例。

      位置的重心坐标，然后用重心坐标做差值。

      投影下不能保证重心坐标不会变化。所以不能在投影之后算重心坐标。

      **当纹理小于分辨率大小**

      - 双线性插值 bilinear  取周围四个像素

      - bicubic  取周围16个像素 插值， 计算开销提高。

      **当纹理过大** 

      简单的uv差值 会出现摩尔纹

      采样跟不上信号变化

      - 不采样，立刻得到平均值， 点查询问题和范围查询问题

      mipmap： 允许范围查询（fast 、approx、 square）只能做近似的**正方形方块**的查询。

      图像金字塔，多余的图片只比原来的一张图多花销1/3图片的内存

      微分， 像素映射到纹理的区域近似到正方形，用mipmap来查询。

      D = log2 L

      mipmap之间可计算三线形插值， 计算离散的mipmap， 得到一个完全的映射的关系。

      **overblur**

      各项异形（在不同的方向上不同）过滤允许对长条形的区域做范围查询， 开销是原来的三倍

      多少x == 计算多少层， 显存足够可以开到最高，和计算能力没有大关系。

      **ewa**

      将不规则的形状拆成圆形，多次查询。

      














































