# let / const
> 作用域： 代码中的某个成员能够起作用的范围；

1. 作用域

     * 全局作用域；

     * 块级作用域（{}) ；

     * 函数作用域；

2. ES6中可以用let定义块级作用域变量

    在ES6之前，我们都是用var来声明变量，而且JS只有函数作用域和全局作用域，没有块级作用域，所以{}限定不了var声明变量的访问范围。

    ```
    { 
      var i = 9;
    } 
    console.log(i);  // 9

    { 
      let i = 9;     // i变量只在 花括号内有效
    } 
    console.log(i);  // Uncaught ReferenceError: i is not defined
    ```
3. ES6中新增const关键词

    > 用来声明只读的常量/衡量；

   * 一旦声明过后不能再修改；

   * const在声明的同时必须设置初始值；

   * const所声明的成员不能被修改，指的是不能修改变量的内存地址；

4. let 和 var的区别

    * let的作用域是是块级作用域；

    * let没有变量提升，会有暂时性死区约束；
    
      > 用let声明的变量，不存在变量提升。而且要求必须 等let声明语句执行完之后，变量才能使用，不然会报Uncaught ReferenceError错误。

      > ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
      总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

    * let变量不能重复声明;

      > let不允许在相同作用域内，重复声明同一个变量。

5. let 配合for循环的独特应用

    ```
    // i虽然在全局作用域声明，但是在for循环体局部作用域中使用的时候，变量会被固定，不受外界干扰。
    for (let i = 0; i < 10; i++) { 
      setTimeout(function() {
        console.log(i);    //  i 是循环体内局部作用域，不受外界影响。
      }, 0);
    }
    ```

6. 定义新的关键词是因为向前兼容；

7. 最佳实践： 不用var, 主用const, 配合let;


