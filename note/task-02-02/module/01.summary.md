# 模块化
> 将复杂按照功能的不同划分成不同模块单独维护去提高开发效率降低维护成本 

1. 演变过程

    1. 按文件划分，按文件划分为一个模块

       > 早期模块化完全依赖约定

       * 没有独立的私有空间，所有成员可以任意的访问和修改,污染全局作用域

       * 很容易常常产生命名冲突

       * 无法管理模块依赖关系

    2. 命名空间方式, 暴露全局对象，成员都挂载在对象下面
       
    3. 立即执行方式，提供私有空间

2. 模块化规定的出现

    > 模块化的标准 + 模块加载器

    1. commonjs规范

        > 是以同步模式加载模块， node的执行机制是启动时加载模块， 浏览器端使用commonjs规范会导致效率低下，出现大量同步模式请求出现
       
       * 一个文件就是一个模块

       * 每个模块都有单独的作用域

       * 通过module.exports 导出成员

       * 通过require函数载入函数

    2. AMD 规范

       > 异步模块定义规范，同期推出requirejs,实现了amd规范，同时也是强大的模块加载器，

       * 约定每个模块必须使用define来定义， 可传递三个参数， 

          1. 模块名称； 

          2. 模块依赖项导出的成员； 

          3. 为当前模块提供私有空间； 

          4. require函数自动加载模块， 

       * 缺点
         
          1. amd用起来相对复杂；

          2. 模块js文件请求频繁；

    3. Sea.js 实现CMD
       
       > 类似commonjs




3. 模块化规范出现

   1. node遵循commonjs 规范， 浏览器遵循es modules规范


      


  


    
        


   

