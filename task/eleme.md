1. **自我介绍，说说你做的项目和亮点，以及难点**

然后紧接着问和项目相关的问题，怎么做的，架构为什么这么做，有没有改进的空间

2. **js 编译原理，介绍下 AST**
 
编译分为三个步骤： 1. 分词： 将字符串分成有效的词法单元； 2. 解析： 将词法单元解析成AST（由元素逐级嵌套所组成的代表了程序语法结构的树）语法树； 3. 代码生成： 将语法树转换为可以执行的代码。这个过程和平台有关，其实也就是转换为一组机器可以执行的指令

3. **事件循环机制，宏任务，微任务**

浏览器的时间循环机制是这样的的， 首先从宏观来说会按照代码编写顺序来执行， 但是我们都知道对于一个项目来说，一般都是会有http请求或其他的异步操作， 这个时候执行顺序就不是这样的了。首先会有一个调用栈， 如果是同步操作依次压入栈中，执行完弹出， 若当前栈中没有事件，则通知事件队列，若当前有微任务，则把当前微任务中的任务依次压入调用栈，执行完弹出， 之后调用栈中若为空，则从宏任务中获取任务，压入调用栈，以此类推。直到调用栈中为空。


4. **node 是单线程，为什么能处理高并发**

    1. 每个node.js的进程只有一个主线程在执行代码，形成一个执行栈 
    2. 主线程之外还有一个事件队列，当用户的网络请求或者异步操作到来时，node都会把它放到事件队列中， 此时不会立即执行它， 代码也不会阻塞，继续往下执行， 知道主线程代码执行完毕
    3. 主线程代码执行完毕之后，通过事件循环机制，开始从事件队列中取出第一个事件， 从线程池中分配一个线程去执行这个事件， 接下来取出第二个事件，再从线程池中分配一个线程去执行， 然后以此类推，执行第三个第四个第n个，主线程不断的检查事件队列中是否还有未执行的事件， 直到事件队列中的所有事件都被执行完毕， 伺候每当有新的事件加入事件队列，都会通知主线程按顺序取出交给事件循环机制来处理，当事件完成后，会通知主线程， 主线程执行回调，线程归还给线程池
    3. 主线程不断重复上面三个步骤。

5. **node 事件循环机制**

node 事件循环机制会有六个阶段: timers、 callbacks、 prepare、 poll、 check、 close callback

  * timers: 执行指定的回调函数，有时间限制。 
  * i\o callbacks：阶段执行一些系统操作的回调, 在这里setImmediate 永远比 settimeout先执行。  
  * poll： 在下限时间已经达到的timers的回调， 然后处理 poll 队列里的事件， 如果有setImmediate 回调需要执行， 则挺值poll阶段，进入check 阶段，如果没有， 则等待被加入队列中立即执行回调， 同样会有一个时间限制。 如果设置了timer， 会判断timer是否超时，如果有的话就会回到timer阶段执行回调。  
  * check: setImmediate()的回调会被加入 check 队列中，从 event loop 的阶段图可以知道，check 阶段的执行顺序在 poll 阶段之后。

  微任务会在所处事件循环最后， 事件循环进入下一阶段之前。


6. **跨域的解决方式，当然主要的就是 jsonp cors 这两种了**
    jsonp, iframe, cors, nginx 代理跨域、postmessage

    我们常说的跨域是狭义的跨域，因为浏览器的同源（协议、域名、端口）策略限制的一类请求(cookie, localstorage\ indexDB, DOM. AJAX)

    1. jsonp

        为了减轻web服务器的负载， 我们把js、 css、 img等静态资源 分离到另一台独立服务器上， 在html页面中在通过相应的标签从不同域名中加载静态资源， 而被浏览器允许，基于这个我们可以通过创建动态的script标签，再请求一个带参数网址 实现跨域

    2. cors

        普通的跨域请求我们可以通过设置acess-control-allow-origin ,前端无需设置， 如果带cookie, 那就需要重写下响应头或者其他相应头的键， 需要设置服务器参数， 并且设置请求的时候设置withCreentials

    3. 设置反向代理

        nginx设置proxy_path ,如果有cookie 设置proxy_cookie_domain
 

7. **缓存机制，主要是问 304 和 强缓存**

    浏览器缓存机制：  
      浏览器每次请求都会读取缓冲中查找该请求的结果和缓存标志；
      浏览器每次拿到返回的请求结果都会把该结果和缓存标志存入浏览器缓存中。

    强缓存： 不会向服务器发送请求， 直接从缓存中读取资源， 在chrome 控制台的network选项中可以看到该请求返回的200状态码， 并且from 显示 from disk cache 或者from memory cache, 强缓存可以设置 expires 和 cache-control,

    expires： 的值是指定资源到期的时间， 是服务器端的具体时间。 

    Cache-Control：表示在请求正确返回时间的多长时间内再次加载资源， 就会命中缓存。

    如果强缓存未命中，浏览器携带缓存标识发起请求， 由服务器缓存标识决定是否使用缓存 的过程。

8. **web安全， 主要是xss csrf**

    sql 注入

    请求的时候再字段内传入一些特殊字符，可能是一些sql语句

    web安全我们常说的有xss 和csfr, 还有一些是代码安全问题和逻辑安全问题。

    xss 跨站脚本攻击： 在目标网站恶意注入js脚本并运行，获取用户信息，影响数据安全等，比较常见的是后台模板生成代码的时候， 在页面内直接绑定用户输入的数据，

    解决方案是 转义一些特定的字符， a链接中href属性禁止javascript开头


9. **udp和tcp的区别**

    tcp（数据传输层协议，）是面向连接的， 可靠的字节流服务， 在首发数据前， 必须和对方建立可靠的连接， 

    udp（用户数据报协议）是一个非连接协议的传输层协议，提供面向事物的简单不可靠的传送服务，传输数据之前源端和终端不建立连接。


    区别： 

      * tcp 是面向连接的， 而udp是无连接的

      * 对系统资源的要求： tcp较多（20个字节信息包）， udp少（udp信息包只有8个字节包）

      * udp程序结构较简单

      * tcp是字节流服务， 而udp是数据报文服务

      * tcp保证数据正确定， 安全可靠， 保证数据顺序， 而udp可能丢包， 而且udp不保证数据顺序。

10. **http2和http1的区别, 优化**

      


    
9. **node 错误处理**

10. **node服务进程守护是如何做的。pm2？（不行的）**

11. **koa 的中间件机制是什么，解决了什么问题，如何实现**

12. **如何理解前后端分离？（这里聊了得十分钟）**

13. **react ssr 实现的难点**

14. **react ssr 如何区分服务端环境还是客户端环境**

15. **多实例如何保存登录态，也就是 session 如何存储**

16. **快应用和微信小程序的底层机制区别**

18. **常用设计模式有哪些，具体应用场景是什么**

19. **数据库死锁如何解决**

20. **介绍下消息队列以及应用**

21. **说说对 mvvm 的理解**


